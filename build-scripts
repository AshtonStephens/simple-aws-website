#!/bin/zsh

# This script is used to install, build, and clean a this project.
# Options:
#  - install
#  - build
#  - lint
#  - test
#  - deploy
#  - clean
#
# If you want, you can string the options together like `./build-scripts install build deploy clean`

## Scratch Notes for Later.
# ----------------------------------------------
# TODO: add installation script.
# You need to download some tools locally:
# - cargo-lambda: https://www.cargo-lambda.info/guide/installation.html
#
# TODO: Include any OPENSSL_DIR related troubleshooting instructions.
#
# TODO: Make local deployment work for
# I've got no idea if this will work across operating systems. On MacOS it'll return
# arm64. This will be important in the future because the rust lambda will only work
# locally computers with ARM64 chips if the lambda is specified to be ARM64 multiple
# places.
#
# I suspect we'll need to have a bunch of "if" statements throughout the
# infrastructure to build in one way on arm systems and another on x86 systems.
# ARCHITECTURE=$(uname -m)

# Get the input parameters

args=("$@")
for arg in "${args[@]}"; do

    # Check the first argument to see what action to take.
    if [[ $arg == "install" ]]; then

        # Install all dependencies at the same time.
        # Redirect stdout to `/dev/null` so we only hear from the command if it's failing.
        echo Installing all dependencies
        (cd cloud_formation && npm install 1> /dev/null) &
        (cd api_definition && npm install  1> /dev/null) &
        (cd website && npm install 1> /dev/null) &
        (cd lambda && poetry install 1> /dev/null) &
        wait

    elif [[ $arg == "build" ]]; then

        # Build cdk api first because it's required for the Rust lambda
        # and the Rust lambda is required for the cloud formation template.
        echo Autogenerating API for Typescript and Rust
        (cd api_definition && npm run build-dev 1> /dev/null)

        # Build the website separately because it depends on the api definition being built.
        # Redirect stdout to `/dev/null` so we only hear from the command if it's failing.
        echo Webpacking Website and Building Rust Lambda
        (cd website && npm run build-dev 1> /dev/null) &
        # This command explicitly sets the architecture to arm64.
        # This likely needs to change for systems running x86.
        (cd lambda-rs && OPENSSL_DIR=/opt/homebrew/opt/openssl/ cargo lambda build --release --output-format zip --arm64) &
        (cd lambda-rs && cargo build 1> /dev/null) &
        wait

        echo Building CDK template
        (cd cloud_formation && npm run build 1> /dev/null) &
        wait

    elif [[ $arg == "lint" ]]; then

        echo "Linting Python"
        (cd lambda && poetry run pylint src tests)

    elif [[ $arg == "test" ]]; then

        echo Testing cdk
        (cd cloud_formation && npm run test)

        echo Testing website
        (cd website && npm run test)

        echo Testing lambda
        (cd lambda && poetry run pytest)

    elif [[ $arg == "deploy" ]]; then

        # Run cdk deploy from cloud_formation directory. Test first to catch any
        # errors that it would take > 1 minute for `cdk deploy` to figure out.
        (cd cloud_formation && npm run test && cdk deploy)

    elif [[ $arg == "clean" ]]; then

        # Clean all workspaces at the same time.
        # Redirect stdout to `/dev/null` so we only hear from the command if it's failing.
        echo Clean Workspaces
        (cd cloud_formation && npm run clean 1> /dev/null) &
        (cd api_definition && npm run clean 1> /dev/null) &
        (cd website && npm run clean 1> /dev/null) &
        (cd lambda && poetry cache clear --all . 1> /dev/null) &
        (cd lambda-rs && cargo clean 1> /dev/null) &
        wait

    elif [[ $arg == "sam-start-api" ]]; then

        echo "Running SAM."

        # Startup the DynamoDB environment. By default it knows of no existing
        # DynamoDB tables.
        sudo docker compose down --remove-orphans
        sudo docker compose up -d

        # This must match the environment variable in the lambda environment vars
        # under docker/lambda/env.json
        MESSAGE_TABLE_NAME="MessageTable-local"

        # Create the DynamoDB table to store the messages.
        # This may complain that the table already exists, but it doesn't matter.
        aws dynamodb create-table \
            --table-name "$MESSAGE_TABLE_NAME" \
            --attribute-definitions AttributeName=id,AttributeType=S \
            --key-schema AttributeName=id,KeyType=HASH \
            --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
            --endpoint-url http://localhost:8000 \
            --output text 1> /dev/null

        # Run the lambda-backed API.
        (
            echo "sythesize and launch api with SAM"
            cd cloud_formation
            cdk synth -q --no-staging > /dev/null
            sam local start-api \
                --env-vars $PWD/../docker/lambda/env.json \
                --docker-network "aws-local-vpc" \
                -t ./cdk.out/CloudFormationStack.template.json
            # TODO: use nohup to run `sam` in the background and expand the
            # "down" command to use `ps -ef | grep start-api` to find and
            # gracefully kill sam.
        )

        # This will never run because the sam command doesn't run in the background.
        # If you paste this snippet onto the command line it'll make a message and
        # then retrieve it.
        (
            # make a message.
            RESPONSE=$(curl -X POST -d "little demo string" localhost:3000/messages)
            echo $RESPONSE | jq

            # retrieve the message.
            curl -X GET localhost:3000/messages/$(echo $RESPONSE | jq -r ".id")
        )

    elif [[ $arg == "down" ]]; then
        sudo docker compose down --remove-orphans
    else
        echo "Invalid parameter"
    fi

    echo "$arg done"
done